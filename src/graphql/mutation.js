import { GraphQLObjectType, GraphQLString, GraphQLNonNull, GraphQLList } from "graphql";
import { upperFirst, mergeWith, camelCase } from "lodash";
import { attributeFields } from "graphql-sequelize";
import { globalIdField, fromGlobalId } from "graphql-relay";
import { customizer } from "../utils";
import { createObjectType } from "./type";

export function attributeInputFields(model, options) {
  options = Object.assign({}, {
    globalId: true
  }, options || {});

  const exclude = options.exclude || [];

  options.exclude = (key) => {
    return ~exclude.indexOf(key)
      || (model.rawAttributes[key]._autoGenerated
        && !model.rawAttributes[key].references
        && !model.rawAttributes[key].primaryKey)
  }

  let fields = attributeFields(model, {
    commentToDescription: true,
    globalId: false,
    exclude: options.exclude
  });

  return Object.keys(fields).reduce((obj, key) => {
    if (options.only && !~options.only.indexOf(key)) {
      delete obj[key];
      return obj;
    }

    if (options.globalId && model.rawAttributes[key]
      && (model.rawAttributes[key].references) || model.rawAttributes[key].primaryKey) {
      obj[key] = { type: model.rawAttributes[key].allowNull ? GraphQLString : new GraphQLNonNull(GraphQLString) };
    }

    return obj;
  }, fields);
}

export function inputArgsToWhere(model, args) {
  return Object.keys(args).reduce((obj, key) => {
    if (model.rawAttributes[key] && (model.rawAttributes[key].references || model.rawAttributes[key].primaryKey)) {
      obj[key] = parseInt(fromGlobalId(args[key]).id, 10);
    } else {
      obj[key] = args[key];
    }

    return obj;
  }, {});
}

export function createMutations(model, nodeInterface) {
  const name = upperFirst(model.name);

  const options = mergeWith({
    create: {
      exclude: []
    },
    update: {
      exclude: []
    },
    delete: {}
  }, model.options, customizer);

  const { before, create, update } = options;

  create.exclude.push(model.primaryKeyAttribute);

  const objectType = createObjectType(model, nodeInterface);

  if (model.primaryKeyAttributes.length > 1) {
    return {};
  }

  return Object.assign({
    [`create${name}`]: {
      name: `Create${name}`,
      inputFields: attributeInputFields(model, { exclude: create.exclude }),
      outputFields: {
        [camelCase(objectType.name)]: {
          type: objectType,
          resolve: function (source) {
            return source;
          },
        }
      },
      mutateAndGetPayload(args, context, info) {
        args = inputArgsToWhere(model, args);

        if (before) {
          before(args, context, info);
        }

        if (create.before) {
          create.before(args, context, info);
        }

        return model.create(args).then((row) => {
          if (create.after) {
            create.after(args, context, info, row);
          }

          return row;
        });
      }
    },
    [`update${name}`]: {
      name: `Update${name}`,
      inputFields: attributeInputFields(model, { exclude: update.exclude }),
      outputFields: {
        [camelCase(objectType.name)]: {
          type: objectType,
          resolve: function (source) {
            return source;
          },
        }
      },
      mutateAndGetPayload(args, context, info) {
        args = inputArgsToWhere(model, args);

        return model.findById(args.id).then((row) => {
          if (!row) {
            throw new Error(`${model.name} not foud`);
          }

          if (before) {
            before(args, context, info);
          }

          if (update.before) {
            update.before(args, context, info, row);
          }

          return row.update(args);
        }).then((row) => {
          if (update.after) {
            update.after(args, context, info, row);
          }

          return row;
        });
      }
    },
    [`delete${name}`]: {
      name: `Delete${name}`,
      inputFields: attributeInputFields(model, { only: model.primaryKeyAttributes }),
      outputFields: {
        [camelCase(objectType.name)]: {
          type: objectType,
          resolve: function (source) {
            return source;
          },
        }
      },
      mutateAndGetPayload(args, context, info) {
        args = inputArgsToWhere(model, args);

        return model.findById(args.id).then((row) => {
          if (!row) {
            throw new Error(`${model.name} not found`);
          }

          if (before) {
            before(args, context, info);
          }

          if (options.delete.before) {
            options.delete.before(args, context, info, row);
          }

          return row ? row.destroy().then(() => {
            if (options.delete.after) {
              options.delete.after(args, context, info, row);
            }

            return row;
          }) : {};
        });
      }
    }
  }, createAssociationMutations(model, nodeInterface));
}

export function createAssociationMutations(model, nodeInterface) {
  const name = upperFirst(model.name);
  const { id } = attributeInputFields(model, { only: model.primaryKeyAttributes });
  const objectType = createObjectType(model, nodeInterface);

  return Object.keys(model.associations).reduce((obj, e) => {
    const association = model.associations[e];
    const associationName = upperFirst(e);

    if (association.associationType !== "BelongsToMany") {
      return obj;
    }

    const { manyToMany } = mergeWith({
      manyToMany: {},
    }, association.target.options, customizer);

    const fields = attributeInputFields(association.target, { only: association.target.primaryKeyAttribute });
    const fieldName = camelCase(association.target.name) + "Ids";
    const inputFields = {
      id,
      [fieldName]: { type: new GraphQLNonNull(new GraphQLList(fields[association.target.primaryKeyAttribute].type)) }
    }

    obj[`add${name}${associationName}`] = {
      name: `Add${name}${associationName}`,
      inputFields: inputFields,
      outputFields: {
        [camelCase(objectType.name)]: {
          type: objectType,
          resolve: function (source) {
            return source;
          },
        }
      },
      mutateAndGetPayload(args, context, info) {
        args.id = parseInt(fromGlobalId(args.id).id, 10);
        args[fieldName] = args[fieldName].map((i) => {
          return parseInt(fromGlobalId(i).id, 10);
        });

        return model.findById(args.id).then((row) => {
          if (!row) {
            throw new Error(`${model.name} not found`);
          }

          return association.target.findAll({ where: { id: { $in: args[fieldName] } } }).then((items) => {
            if (manyToMany.before) {
              manyToMany.before(context, row, items);
            }

            row[`add${associationName}`](items);

            if (manyToMany.after) {
              manyToMany.after(context, row, items);
            }

            return row.save();
          });
        });
      }
    };

    obj[`remove${name}${associationName}`] = {
      name: `Remove${name}${associationName}`,
      inputFields: inputFields,
      outputFields: {
        [camelCase(objectType.name)]: {
          type: objectType,
          resolve: function (source) {
            return source;
          },
        }
      },
      mutateAndGetPayload(args, context, info) {
        args.id = parseInt(fromGlobalId(args.id).id, 10);
        args[fieldName] = args[fieldName].map((i) => {
          return parseInt(fromGlobalId(i).id, 10);
        });

        return model.findById(args.id).then((row) => {
          if (!row) {
            throw new Error(`${model.name} not found`);
          }

          return association.target.findAll({ where: { id: { $in: args[fieldName] } } }).then((items) => {
            if (manyToMany.before) {
              manyToMany.before(context, row, items);
            }

            row[`remove${associationName}`](items);

            if (manyToMany.after) {
              manyToMany.after(context, row, items);
            }

            return row.save();
          });
        });
      }
    };

    obj[`set${name}${associationName}`] = {
      name: `Set${name}${associationName}`,
      inputFields: inputFields,
      outputFields: {
        [camelCase(objectType.name)]: {
          type: objectType,
          resolve: function (source) {
            return source;
          },
        }
      },
      mutateAndGetPayload(args, context, info) {
        args.id = parseInt(fromGlobalId(args.id).id, 10);
        args[fieldName] = args[fieldName].map((i) => {
          return parseInt(fromGlobalId(i).id, 10);
        });

        return model.findById(args.id).then((row) => {
          if (!row) {
            throw new Error(`${model.name} not found`);
          }

          return association.target.findAll({ where: { id: { $in: args[fieldName] } } }).then((items) => {
            if (manyToMany.before) {
              manyToMany.before(context, row, items);
            }

            row[`set${associationName}`](items);

            if (manyToMany.after) {
              manyToMany.after(context, row, items);
            }

            return model.findById(args.id);
          });
        });
      }
    };

    return obj;
  }, {});
}